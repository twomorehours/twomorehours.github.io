单机存储
    存储引擎
        提供存储系统的CRUD的能力，决定存储性能的功能和性能
    性能因素
        写入方式
            随机写
            顺序写
        读取方式
            随机读
            顺序扫描
    物理存储引擎分类
        Hash引擎
            原理：用PK定位 file pos size
            场景：点查O(1)
            特点
                点查O(1)
                不支持排序，不支持范围查询
            产品
                Redis
                Memcached

        Btree引擎
            原理：用B+树存储
            场景：点查 范围
            特点
                根节点常驻内存，最多h-1次磁盘IO
                非叶子节点容纳更多的元素，降低树的高度，减少磁盘IO次数（拆会增加高度 从下到上）
                本身有序，擅长范围查询
                随机写，页分裂问题
            产品
                mysql innodb

        LSM引擎
            原理：内存 + 多层文件 + 追加写
            场景：写入
            特点
                随机写编程顺序写
                牺牲读性能
                增加后台开销
            对读性能优化
                布隆过滤器判断key是否存在
                文件内数据有序
                对SSTFile做缓存
            产品
                RocksDB
                levelDB
        
    数据模型分类
        关系型(实体字段)
            MySQL
        键值对（KV）
            Redis
        时序性（发生时间）
            InfluxDB
        图（数据关系）
            Neo4j
Redis
    概念
        C语言开发的开源的高性能的KV型内存数据库
    总体存储原理
        每个DB分别保存着一个元素dict和过期时间dict
        dict中的key是RedisObject，最终指向一个SDS（可变长度字符串）
        dict中的val是各种各样的数据类型，比如sds ziplist skiplist dict list等
    一个key占用内存大小分析
        dicEntry 16b
        RedisObject 12b
        sds 9b
        （16 + 12 + 9 + key）*2 + val
        总结 key要小
    内存清理
        惰性删除
            查询时候发现过期了，直接删除
        定期删除
            如果能删除很多过期，就持续删除
            清理比例 = 0
            while 清理比例 > 0.25{
                清理数量 = 0
                for(i =0; i<20; i++){
                    key = 随机选择
                    if(key is 过期){
                        清理数量 ++
                    }
                }
                清理比例 = 清理数量 / 20
            }
        LRU
            allkeys
            volatile（推荐）
                RedisObject 里面保存着LRU时间
                速记选取几个进行排序，然后进行删除
        LRU
            allkeys
            volatile（推荐）
                RedisObject 里面保存着LRU时间和频率（8bit，有增有减）
                速记选取几个进行排序（频率优先），然后进行删除
    内存固化
        RDB 
            fork子进程dump内存数据 m秒n次
            优点
                文件小
                恢复快
            缺点
                丢数据（耗费cpu 所以频率不能过高）
        AOF
            将命令追加到文件中
            优点
                丢数据少
            缺点
                占用空间大
                恢复慢
            重写
                去掉过期/删除数据 多次更新合一
                阈值判断（最小大小 + 比上次增加的比例超过阈值）
                fork子进程重写 新数据写入aof_rewrite_buf 重新完成后将数据写入新aof文件
    数据恢复
        默认是RDB， AOF优先，没必要同时开启，AOF有覆盖RDB的可能性 如果要固化 推荐AOF
    可用性（优缺点对比）
        主从模式
            全量快照同步
            增量命令同步
            偏移量
                如果在buffer之内就是增量 否则就是全量
            运行ID 
                Master启动时生成，同步给slave
        哨兵模式
            监控
                监控主从运行状态
            故障转移
                主从 自动切换 更新配置
                使用VIP
        集群模式
            支持水平扩容
            支持16383个slot
            每组主从redis负责一些slot
            连接到任何master节点都能做重定向（二次访问 性能问题）
            不能批量操作
        codis
            CodisSever（Redis主从），支持扩展，数据分片逻辑，注册到zk
            CodisProxy（Redis协议代理），无状态，无限扩展，代理请求
            Client -> Haproxy -> CodisProxy ->  CodisSever
            缺点 部署复杂
    Mysql innodb
        存储结构
            Mysql的存储以页为单位
                页头
                    记录控制信息 包含左右页面的指针 页使用情况等
                虚记录
                    最大虚记录
                        比页内最大主键大
                    最小虚记录
                        比页内最小虚记录还小
                记录堆
                    行记录存储区 有效数据 被标记删除的无效数据（满足范围才能复用）
                自由空间链表
                    已删除记录组成的链表
                未分配的空间
                    没有使用的空间
                页尾
                    存储页内数据的校验信息
                索引只能指到页

        页内记录维护
            顺序保证
                页内逻辑连续 
            插入逻辑
                优先复用已经删除链表的空间 然后再使用未分配的空间
            页内查找
                使用slot先找到一个sublist

        索引
            聚簇索引
                数据是存在主键中的
                数据按主键顺序存储
                要尽量使用递增的主键 防止页分裂
            二级索引
                存储的数据是主键值 
                要用主键回表
                主键大小会影响全局索引大小
            联合索引
                BTree由第一列构建
                页里面按照各列有序，越靠前的优先级越高
                要使用左前缀原则
                    不能跳过中间列
                    前面的使用范围 后面不能使用
            优化分析
                存储空间
                    取决于字段大小和字段数量
                主键选择
                    有业务意义 使用业务自增主键
                    没有业务意义，使用数据库自增主键
                联合索引
                    区分度排序
                    索引覆盖
                字符串索引
                    合理设置长度





