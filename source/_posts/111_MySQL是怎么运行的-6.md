---
title: Mysql的事务
date: 2020-04-05 23:30:39
categories:
- MySQL
tags:
- ACID
---

## 什么叫做事务
需要保证事务四大特性的一个或者多张个数据库操作叫做事务

## 事务的四大特性
- Atomic(原子性)
  - 所有操作，要么全部成功，要么全部失败
- Consistent(一致性)
  - 不违反显示世界的规律，比如AB转账前后的总额是不变的
- Isolation(隔离性)
  - 不同的事务之间不应该互相干扰
- Durability(持久性)
  - 已经提交的事务要一直存在

## Mysql事务的使用
- 自动提交事务
  - Mysql是默认自动提交事务的，即使没有显示开启事务，当执行一条语句时也是默认开启并且提交事务
- 手动事务
  - 当要批量执行操作的时候就需要手动开启事务，使用`begin`， 全部执行成功后使用`commit`提交，或者失败情况下使用`rollback`回滚 

## Mysql如何保证事务的持久性
- 保证持久性就是保证Mysql崩溃后，提交的数据不丢失，这就要求提交的数据必须写在磁盘上，但是每次提交都刷写磁盘（随机IO）性能太低，所以Mysql引入了redo log来保证事务的持久性
- redolog的写入
  - 开启事务
  - 修改buffer pool ，修改页的控制块加入flush链表
  - 提交事务
  - 操作的数据写入redo log buffer（这步实际上是有可能丢失数据的）
  - 后台数据将buffer的数据顺序刷写到磁盘上
- redo log保存了什么
  - redo log保存了修改的物理信息，即页号加数据
- redo log怎么使用
  - mysql在异常恢复的时候，会读取redo log的数据重放
- redo log的特征
  - redo log 是循环的 如果要写满了 要强制刷写到数据页
  - redo log很小
  - redo log是分组的，一个影响多条数据的操作会分到一组，这一组保存或者重放时是原子的

## 回滚如何实现
- Mysql在事务操作的时候会保存被修改之前的数据，这样的记录叫做undo log
- undo log可以有多个，根节点是数据的上的roll_pointer, 越新的undo log越靠近roll pointer
- 插入的undo log保存的是插入的id 回滚时直接删除此id
- 更新的undo log保存的是修改了哪些字段的数据
- undo log不能提交之后立即删除，因为MVCC的原因，有可能有些读事务还在引用undo log(快照读的时候，写事务还没有结束)

## 常见的读写一致性问题
-  脏读
   - 读到其他事务未提交的数据
- 不可重复读
  - 一个事物的数据读到了另一个事务在本事务活跃期间提交的数据
- 幻读
  - 一个事务写(当前读)了其他事务在本事务活跃期间提交的数据

## 事务的隔离级别
- READ UNCOMMITTED
  - 读未提交 可能发生脏读，不可重复读，幻读
- READ COMMITTED
  - 读已提交 可能发生不可重复读     幻读 脏读通过MVCC解决
- REPEATABEL READ
  - 读已提交 MYSQL默认级别  可能发生幻读（小概率，因为有Next key lock）  脏读,不可重复读通过MVCC解决
- SERIALIZABLE
  - 序列化 各种显现都不能发生 因为是串行的

## MVCC
`Multi Version Concurrent Control`，多版本并发控制，用来再保证一定隔离性的情况下，提高Mysql的读写并发能力

- READ VIEW
MVCC中有一个读快照的东西，一个事务在特定时候（后面说）会产生一个快照，然后用快照保存的信息，和数据的undo log链上的事务id进行比较，找到此事务应该读取的版本

- READ VIEW的构成
  - trx_ids数组： 当前所有活跃的事物id
  - min_trx_id: trx_ids数组里面的最小值
  - max_trx_id: mysql下一个要生成的事物id

- READ VIEW和版本链的对比步骤
    - 判断当前数据的trx_id是不是本事务，如果是，证明本事务正在修改这条数据，则可见
    - 如果不是本事务，那就从roll_ptr开始遍历
    - 如果判断事务id小于min_trx_id，证明在本事务开启之前就有了，则可见
    - 如果事务id大于max_trx_id，证明是本事务之后的事务，则不可见
    - 如果事务id在两者之间，那就判断事务id是否在trx_ids数组中，如果不在，则证明这个事务也是在本事务之前提交的，也可见，否则不可见
- READ VIEW的生成时机
  - READ COMMITTED
    - 每次查询的时候都会生成，所以能够查到其他事务在本事务之前提交的数据，但是不能查到未提交的数据，因为在数组中存在或者比max_trx_id更大
  - REPEATABEL READ
    - 只在第一次查询的时候生成一次，所以查不到在此事务期间其他事物提交的数据，因为其他事务要么在数组中存在或者比max_trx_id更大

## InnoDB的锁
- 锁是一个内存结构，保存着加锁事务的id和等待状态，锁和索引关联
- 一个事务要加锁的时候首先判断这条数据有没有锁，如果没有则生成一个结构waiting=false, 如果有则waiting=true
- 当一个事务执行结束之后释放锁的时候，会唤醒其他等待的事务
- insert 、update、 in share mode 、 for update 会加锁
- 行锁
  - 顾名思义，锁一行
- 间隙锁
  - 锁一个索引数据到之前一个索引范围的间隙，前开后开
- Next Key Lock
  - 是行锁换个间隙锁合在一起的叫法，加锁的单位都是Next Key Lock，即前开后闭
- 加锁原则
  - 所有的锁都加在索引上，如果一个索引都没有，那也是关联在主键索引上
  - 扫描到对象会加锁，举个例子，一个索引是非唯一索引，那么查询的时候一定查询到一个不满足的数据为止，那么第一个不满足的数据就会被扫描到
  - 如果是等值查询，如果是唯一索引，那么不会加间隙锁只会加行锁，因为查出来的数据没有间隙，不会有新数据插入
  - 如果是等值查询，如果是非唯一索引，第一个扫描到的不满足的数据不会加行锁，只加间隙锁
  - order desc的扫描顺序是从后往前
- Repeatable Read的情况下 for udapte 会加gap lock， 防止范围内插入数据，造成幻读
- UCR CR RR 默认读都不加锁
- DDL时最开始会加MDL写锁，此时DML不能执行，DDL获取到MDL写锁之后，会降级为MDL读锁，此时DML可以执行，当DDL执行结束后会再次获取MDL写锁，获取写锁的目的是两个DDL不能同时执行