---
title: MySQL常见面试题分析
date: 2020-03-08 23:30:39
categories:
- MySQL
tags:
- BTree
- LRU
- 聚集索引
- 二级索引
- 联合索引
- 左前缀法则
---

## InnoDB的存储结构
- Mysql的存储以页为单位
    - 页头
        - 记录控制信息，包含左右页面的指针，页使用情况等
    - 虚记录
        - 用于快速确定页内数据的范围
        - 最大虚记录
            - 比页内最大主键大
        - 最小虚记录
            - 比页内最小虚记录还小
    - 记录堆
        - 行记录存储区 
            - 有效数据 
            - 被标记删除的无效数据
    - 未分配区域
        - 还未使用的空间
    - 自由空间链表
        - 标记删除记录组成的链表（页中放入数据时优先使用）
    - 页尾
        - 存储页内数据的校验信息
    
- 页内记录的维护
    - 顺序保证
        - 页内逻辑连续，即分配的空间不是物理上连续的，而是通过链表维护的先后顺序 
    - 插入逻辑
        - 优先复用已经标记删除链表的空间，然后再使用未分配的

- 页内查找
    - 页内使用二分查找进行搜索

## InnoDB的索引
- 索引的分类
    - 聚集索引
        - 数据是存在主键索引树中的
        - 数据按主键顺序存储
        - 要尽量使用递增的主键，防止页分裂
    - 二级索引
        - 叶子节点存储的数据是主键值 
        - 要用主键回表
        - 主键大小会影响全局索引大小
    - 联合索引
        - 联合索引也是一种二级索引，只不过由多个字段组合而成，一个联合索引只有一棵索引树
            - BTree由第一列构建
            - 页里面按照各列有序，越靠前的优先级越高
            - 要使用左前缀原则
                - 不能跳过中间列
                - 前面的使用范围查询 ，后面索引不能使用
- 优化分析
    - 主键选择
        - 有业务意义 使用业务自增主键
        - 没有业务意义，使用数据库自增主键
    - 联合索引
        - 按照区分度排序，越高越靠前，低了没必要做索引
        - 常用查询合理使用索引覆盖
        - 字符串索引，合理设置长度，否则会导致索引过大 

## InnoDB的内存管理 
- 内存池
    - BufferPool 
        - InnoDB的整个分配内存的总称
    - Page Hash 
        - 内存页和磁盘页的映射关系
    - Free List 
        - 空闲页链表，分配内存使用
    - Flush List 
        - 脏页，数据写到内存中，还没有刷到磁盘上
    - Clean List 
        - 数据页，保存正常的数据
    - LRU List 
        - LRU链表，里面保存着数据页和脏页

- 内存页的写入和写出
    - 当数据从磁盘中读取之后，加载到内存中
    - 首先从空闲页链表中寻找位置，如果找到了，就载入内存，并且加入LRU链表
    - 如果空闲链表没有位置，就从LRU中选择一个最老的淘汰掉，然后载入内存，并且加入LRU链表
    - 数据页可以直接被淘汰
    - 脏页在被淘汰之前必须先将数据刷到磁盘上

- LRU的实现
    - 普通的LRU
        - 单个链表
        - 有新的数据就放到头，并且淘汰最老的数据
        - 不能应对全表扫描的情况，会冲掉真正的热数据
    - MySQL分段LRU
        - 链表分为new和old，比例为5:3
        - 新数据首次加载放入old区域
        - 当访问数据时，如果数据在old区，那么判断这个数据在old区的时长是否超过了阈值，如果超过了就放入new区，new区放不下的情况下，淘汰到old区
        - 新数据放入时淘汰数据只从old区淘汰，这就解决了全表扫描的问题

- InnoDB的事务管理
    - 事务特性
        - A 全部成功或者失败
        - C 数据操作前后一致（整体一致）
        - I 事务之间互不干扰
        - D 提交的数据不丢失
    - 常见的事务并隔离问题
        - 脏读
            - 一个事务读到其他事务未提交的数据
        - 不可重复读
            - 一个事务读到其他事务在本事务未完成时提交了的数据
        - 幻读
            - 更新（当前读）了其他事务已经提交的数据

    - 隔离级别
        - RU
            -  一个事务可以读到其他事务未提交的数据
        - RC
            - 一个事务可以读到其他事务在本事务未完成时提交了的数据
        - RR（MySQL默认）
            - 一个事务读不到到其他事务在本事务未完成时提交了的数据，但是可以更新到
        - Serial
            - 所有事务串行化，没有并发问题

    - MVCC
        - 解决读写并发的问题（多版本），最终解决策略是我只读到我开启事务时的版本
            - 当前读 
                - 永远读最新的 一般用于update
            - undolog
                - 记录一条数据的多个版本，支持mvcc
                - 指向事务开始之前的数据，作为回滚之用
                - 何时清理undolog
                    - 回滚，直接删除，因为还没有快照读能引用
                    - 清理比最小的活跃事务id还老的undolog
            - 快照读
                - 创建快照时刻的活跃的事务Id记录下来，查询时候不查询这些事务提交的数据的
                    从最新的查找undolog，如果比最小的活跃还小，就是在我之前提交的，是能查到的
                - RR，RC的实现，区别是RR创建一次快照，所以整个事务的看到视图是一致的，但是RC是每次都创建快照，所以能读到别的事务提交的数据
                
            - redolog
                - 意义：顺序写，速度很快 刷盘量小，没有整个页刷盘那么大
                - 数据恢复
            - 写数据流程
                - 写undolog
                - 写内存
                - 写redolog
                - 提交
                - 生效redolog
                - 生效内存

