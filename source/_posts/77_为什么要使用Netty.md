---
title: 为什么用使用netty
date: 2020-03-05 23:30:39
categories:
- Netty
tags:
- 阻塞
- 同步
- 异步
- 非阻塞
- C10K
- IO多路复用
- BIO
- NIO
- 粘包拆包
---

## IO过程
IO其实大体上可以分为两步
- 知道数据可读
    - 这种就说明网络数据已经写入到socket缓冲区里面了
- 读取数据
    - 这种就是从socket缓冲区里面读取数据
## 名词定义
- 阻塞
    - IO过程中由IO导致线程挂起等待就是阻塞
- 非阻塞
    - IO过程中线程一直没有因为IO挂起就是非阻塞
- 同步
    - 整个IO过程中有阻塞就是同步（数据是自己读回来的）
- 异步
    - 整个IO过程中完全非阻塞就是异步（数据是回调回来的）

## IO模型
- 同步
    - 阻塞（可读？） + 阻塞（读）
        - 用户线程一直去阻塞等待某个socket可读，直到所有数据读取完成之后才返回
    - 非阻塞（可读？） + 阻塞（读）
        - 用户线程不断轮询去判断某些socket是否可读，直到可读，阻塞等待某个socket读取完成，继续循环
    - IO多路复用（NIO + Selector） （阻塞（可读？） + 非阻塞（读））
        - 用户线程驱动selector同时判断某些socket是否可读，直到可读，阻塞等待某个socket读取完成，继续循环
- 异步（AIO）
    - 非阻塞（注册） + 非阻塞（数据回调）
        - 用户线程将读某个socket的注册到内核，有数据时内核会将数据回调给用户

## 为什么用使用NIO
- 同步阻塞的模型下，每个线程只能处理一个连接，吞吐量极其低下，不能处理大量连接，也就是C10K问题
- 同步非阻塞模式下，每个线程可以处理多个连接，但是用户线程主动轮训，效率依然很低
- IO多路复用模式下，利用内核的函数（epoll/kqueue等）直接返回可读的socket，效率高
- AIO还不成熟，使用的不多

## 为什么要使用Netty
- 传统NIO不能很好的解决[粘包拆包](https://www.yuhao.pro/2019/09/07/02_%E6%8B%86%E5%8C%85%E7%B2%98%E5%8C%85/)的问题，而Netty提供了一系列的Encoder和Decoder，可以很好的解决这种问题
- 传统NIO编码复杂，而Netty提供了一种pipeline模式，也就是责任链，可以简化编码，事使用方更关注业务
- Netty中做了大量的性能优化，如`对象池`、`内存分配`等，可以有效的提升性能