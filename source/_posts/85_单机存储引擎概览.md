---
title: 单机存储引擎设计
date: 2020-08-03 23:30:39
categories:
- 存储
tags:
- 哈希表
- BTree
- LRU
- LFU
- LSM-TRee
- 聚集索引
- 二级索引
- 联合索引
- 左前缀法则
---

## 什么是存储引擎
提供存储系统的CRUD的能力，决定存储性能的功能和性能

## 影响存储引擎性能的因素
一般来说大多数都采用`顺序写 + 随机读 + 读缓存`的方式
- 写入方式
    - 随机写
    - 顺序写
- 读取方式
    - 随机读
    - 顺序扫描

## 物理存储引擎分类
- Hash引擎
    - 原理
      - 用key做hash计算，取出存储真实数据的位置(file:文件 pos:偏移量 size:数据大小)
    - 使用场景
      - 点查O(1)
    - 特点
      - 点查O(1)，KV使用时间复杂度低
      - 
      - 数据无序(key和实际数据均无序)，所以支持索引排序，也不支持索引范围查询
    - 产品
      - Redis
      - Memcached

- Btree引擎
    - 原理
        - 用B+树存储，数据物理有序
    - 使用场景
        - 点查O(logN)
        - 范围O(logN)
    - 特点
        - 根节点常驻内存，最多h-1次磁盘IO
                非叶子节点容纳更多的元素，降低树的高度，减少磁盘IO次数（拆会增加高度 从下到上）
                本身有序，擅长范围查询
                随机写，页分裂问题
            产品
                mysql innodb

        LSM引擎
            原理：内存 + 多层文件 + 追加写
            场景：写入
            特点
                随机写编程顺序写
                牺牲读性能
                增加后台开销
            对读性能优化
                布隆过滤器判断key是否存在
                文件内数据有序
                对SSTFile做缓存
            产品
                RocksDB
                levelDB
        
    数据模型分类
        关系型(实体字段)
            MySQL
        键值对（KV）
            Redis
        时序性（发生时间）
            InfluxDB
        图（数据关系）
            Neo4j
Redis
    概念
        C语言开发的开源的高性能的KV型内存数据库
    总体存储原理
        每个DB分别保存着一个元素dict和过期时间dict
        dict中的key是RedisObject，最终指向一个SDS（可变长度字符串）
        dict中的val是各种各样的数据类型，比如sds ziplist skiplist dict list等
    一个key占用内存大小分析
        dicEntry 16b
        RedisObject 12b
        sds 9b
        （16 + 12 + 9 + key）*2 + val
        总结 key要小
    内存清理
        惰性删除
            查询时候发现过期了，直接删除
        定期删除
            如果能删除很多过期，就持续删除
            清理比例 = 0
            while 清理比例 > 0.25{
                清理数量 = 0
                for(i =0; i<20; i++){
                    key = 随机选择
                    if(key is 过期){
                        清理数量 ++
                    }
                }
                清理比例 = 清理数量 / 20
            }
        LRU
            allkeys
            volatile（推荐）
                RedisObject 里面保存着LRU时间
                速记选取几个进行排序，然后进行删除
        LRU
            allkeys
            volatile（推荐）
                RedisObject 里面保




    LRU
            allkeys
            volatile（推荐）
                RedisObject 里面保存着LRU时间
                速记选取几个进行排序，然后进行删除
        LRU
            allkeys
            volatile（推荐）
                RedisObject 里面保存着LRU时间和频率（8bit，有增有减）
                速记选取几个进行排序（频率优先），然后进行删除
    内存固化
        RDB 
            fork子进程dump内存数据 m秒n次
            优点
                文件小
                恢复快
            缺点
                丢数据（耗费cpu 所以频率不能过高）
        AOF
            将命令追加到文件中
            优点
                丢数据少
            缺点
                占用空间大
                恢复慢
            重写
                去掉过期/删除数据 多次更新合一
                阈值判断（最小大小 + 比上次增加的比例超过阈值）
                fork子进程重写 新数据写入aof_rewrite_buf 重新完成后将数据写入新aof文件
    数据恢复
        默认是RDB， AOF优先，没必要同时开启，AOF有覆盖RDB的可能性 如果要固化 推荐AOF
    可用性（优缺点对比）
        主从模式
            全量快照同步
            增量命令同步
            偏移量
                如果在buffer之内就是增量 否则就是全量
            运行ID 
                Master启动时生成，同步给slave
        哨兵模式
            监控
                监控主从运行状态
            故障转移
                主从 自动切换 更新配置
                使用VIP
        集群模式
            支持水平扩容
            支持16383个slot
            每组主从redis负责一些slot
            连接到任何master节点都能做重定向（二次访问 性能问题）
            不能批量操作
        codis
            CodisSever（Redis主从），支持扩展，数据分片逻辑，注册到zk
            CodisProxy（Redis协议代理），无状态，无限扩展，代理请求
            Client -> Haproxy -> CodisProxy ->  CodisSever
            缺点 部署复杂
    Mysql innodb
        存储结构
            Mysql的存储以页为单位
                页头
                    记录控制信息 包含左右页面的指针 页使用情况等
                虚记录
                    最大虚记录
                        比页内最大主键大
                    最小虚记录
                        比页内最小虚记录还小
                记录堆
                    行记录存储区 有效数据 被标记删除的无效数据（满足范围才能复用）
                自由空间链表
                    已删除记录组成的链表
                未分配的空间
                    没有使用的空间
                页尾
                    存储页内数据的校验信息
                索引只能指到页

        页内记录维护
            顺序保证
                页内逻辑连续 
            插入逻辑
                优先复用已经删除链表的空间 然后再使用未分配的



        已删除记录组成的链表
                未分配的空间
                    没有使用的空间
                页尾
                    存储页内数据的校验信息
                索引只能指到页

        页内记录维护
            顺序保证
                页内逻辑连续 
            插入逻辑
                优先复用已经删除链表的空间 然后再使用未分配的空间
            页内查找
                使用slot先找到一个sublist

        索引
            聚簇索引
                数据是存在主键中的
                数据按主键顺序存储
                要尽量使用递增的主键 防止页分裂
            二级索引
                存储的数据是主键值 
                要用主键回表
                主键大小会影响全局索引大小
            联合索引
                BTree由第一列构建
                页里面按照各列有序，越靠前的优先级越高
                要使用左前缀原则
                    不能跳过中间列
                    前面的使用范围 后面不能使用
            优化分析
                存储空间
                    取决于字段大小和字段数量
                主键选择
                    有业务意义 使用业务自增主键
                    没有业务意义，使用数据库自增主键
                联合索引
                    区分度排序
                    索引覆盖
                字符串索引
                    合理设置长度

        内存管理
            预分配磁盘空间
                分配内存池
                    BufferPool 内存池
                    Page Hash 页映射
                    Free List 空闲页
                    Flush List 脏页
                    Clean List 数据页
                    LRU List LRU链表
                内存页面管理
                    内存页面的映射
                    页面数据的管理
                        加载和更新
                    淘汰
                        内存分类淘汰
                            数据页  直接淘汰
                            脏页    刷盘淘汰
                        淘汰机制
                            普通LRU
                                不兼容全表扫描的情况 大量非热点数据占用内存 挤出热点数据 需要重新加载
                            分段LRU
                                new区 old区
                                页面装载
                                    从Free List中寻找，如果有空间，放入，放到old取里面最新
                                    如果没有空间，从old区淘汰能淘汰的最老的一个，然后放到old里面最新
                                    如果还没有找到 取脏页刷盘淘汰 加到FreeList 然后取出 然后放到old里面最新
                                读取
                                    读取数据时，如果是在old区，并且超过old存活时间就new区最新
                                    如果此时new已经满了，就把new最新的放到old最新
                            


            数据以Page为单位加载
            数据内外存交换

        事务管理
            事务概念
                A 全部成功或者失败
                C 数据操作前后一致（整体一致）
                I 事务之间互不干扰
                D 提交的数据不丢失
            
            并发问题
                脏读
                    一个事务读到其他事务未提交的数据
                不可重复读
                    一个事务读到其他事务在本事务未完成时提交了的数据
                幻读
                    更新（当前读）了其他事务已经提交的数据

            隔离级别
                RU 
                RC
                RR
                Serial

            MVCC
                解决读写并发的问题（多版本），最终解决策略是我只读到我开启事务时的版本
                当前读 
                    永远读最新的 一般用于update
                快照读
                    根据事务id 决定读到哪个版本
                可见性判断
                    创建快照时刻的活跃的事务Id记录下来，查询时候不查询这些事务提交的数据的
                    从最新的查找，如果比最小的活跃还小，就是在我之前提交的，是能查到的
                undolog
                    记录多版本，支持mvcc
                    回滚日志
                    何时清理undolog
                        回滚 直接删除
                        清理比最小的活跃事务还老的undolog
                redolog
                    意义：顺序写，速度很快 刷盘量小，没有整个页刷盘那么大
                    数据恢复
                    顺序写文件（循环写）
                        定时刷盘
                        写满刷盘
        写数据流程
            写undolog
            写内存
            写redolog
            提交
            生效redolog
            生效内存
        redolog刷盘时机
            写内存 每秒写文件+刷盘
            写到OS BUFFER 每秒刷盘
            写OS BUFFER 每次刷盘

        使用经验
            联合索引
                区分度高的放前面
                索引覆盖
                既要满足查询也要满足排序 左前缀


分布式数据库
    意义
        分库分表来水平扩展
            业务侵入大
        存储量可以无限水平扩展
        计算能力可以无限水平扩展
        数据可靠性高（多副本）
    实现
        多副本
            保证数据一致性
            一般是KV
            实时调整块的位置 将读写频繁的块 均匀的分布到各个节点上
        主从
            多个主从节点 + 路由节点
        
    选型
        AP
        CP：一般都是
