---
title: Redis的性能基础
date: 2020-04-27 23:30:39
categories:
- Redis
tags:
- ziplist
---

## Redis的底层数据结构
- SDS
	- Simple Dynamic String
	- 这个字符串类似于Java中的StringBuilder，内部是数组，如果长度变化了，先看原来的数据长度够不够，如果够了就不需要扩容
- Ziplist
	- 压缩列表
	- 类似于数组，是连续内存的数据，结构简单，能有效的提升内存的利用率，对Cpu缓存友好，在Redis中被广泛使用,头尾操作O(1),因为数据结构中记录了尾节点的offset
- Hash表
	- 哈希表， 整个Redis最外层的索引就是Hash表，时间复杂度O(1), 是Redis高性能的基础
- Skiplist
	- 跳表
	- 类似于B树的数据结构，由多层链表实现，整体有序，查询是从上到下，从左到右，每上一层，节点数差不到少一半（概率），上层作为下层的索引，整体复杂度O(logN)
- 整数数组
	- 在存储少量整数的时候会用到，核心是为了减少内存
- 双向链表
	- 非常常用的数据结构，头尾操作O(1), 其余操作O(N)

## Redis的逻辑数据结构
- String
	- 底层使用的SDS，几乎是最常用的数据结构
- List
	- 底层使用的是ziplist或者双向链表， 推荐使用pop，push等O(1)操作，当做队列使用
- Set
	- 底层使用整数数组，ziplist或者hash表，适用于存储一个对象多个属性，并且指定存取的情况
- Zset
	- 使用ziplist或者跳表，适用于需要排序的情况

## Redis的渐进式rehash
- Redis最最外层本身就是一个非常大Hash表，如果Key非常多，那么就会造成非常严重的Hash冲突，导致一个bucket下的链表非常的长，可能退化为O(n)
- 这个时候就需要更换为一个容量更大的hash表，但是如果一次执行全部数据的Rehash的话，会阻塞所有的客户端请求
- Redis使用了渐进式rehash的方式。来一个用户请求就顺带迁移一个bucket的数据到新hash表中，把延迟均匀分布到每一个请求上，这样就不会导致假死