---
title: Redis的性能基础
date: 2020-04-27 23:30:39
categories:
- Redis
tags:
- ziplist
---

## Redis的底层数据结构
- SDS
	- Simple Dynamic String
	- 这个字符串类似于Java中的StringBuilder，内部是数组，如果长度变化了，先看原来的数据长度够不够，如果够了就不需要扩容
- Ziplist
	- 压缩列表
	- 类似于数组，是连续内存的数据，结构简单，能有效的提升内存的利用率，对Cpu缓存友好，在Redis中被广泛使用,头尾操作O(1),因为数据结构中记录了尾节点的offset
- Hash表
	- 哈希表， 整个Redis最外层的索引就是Hash表，时间复杂度O(1), 是Redis高性能的基础
- Skiplist
	- 跳表
	- 类似于B树的数据结构，由多层链表实现，整体有序，查询是从上到下，从左到右，每上一层，节点数差不到少一半（概率），上层作为下层的索引，整体复杂度O(logN)
- 整数数组
	- 在存储少量整数的时候会用到，核心是为了减少内存
- 双向链表
	- 非常常用的数据结构，头尾操作O(1), 其余操作O(N)

## Redis的逻辑数据结构
- String
	- 底层使用的SDS，几乎是最常用的数据结构
- List
	- 底层使用的是ziplist或者双向链表， 推荐使用pop，push等O(1)操作，当做队列使用
- Set
	- 底层使用整数数组，ziplist或者hash表，适用于存储一个对象多个属性，并且指定存取的情况
- Zset
	- 使用ziplist或者跳表，适用于需要排序的情况

## Redis的渐进式rehash
- Redis最最外层本身就是一个非常大Hash表，如果Key非常多，那么就会造成非常严重的Hash冲突，导致一个bucket下的链表非常的长，可能退化为O(n)
- 这个时候就需要更换为一个容量更大的hash表，但是如果一次执行全部数据的Rehash的话，会阻塞所有的客户端请求
- Redis使用了渐进式rehash的方式。来一个用户请求就顺带迁移一个bucket的数据到新hash表中，把延迟均匀分布到每一个请求上，这样就不会导致假死

## Redis为什么使用单线程
- 能保证相对高的性能
	- Redis主流程是纯内存操作，且比较简单，性能很高
	- Redis使用了I/O复用的网络模型，单线程即可处理大量的连接数
	- Redis的耗时操作都是异步进行的，比如持久化等
	- 单线程可以减少锁的开销
	- 单线程可以降低cpu上下文切换的消耗
- 减少同步代码的编码，降低代码复杂度，提升可维护性
	- 比如分布式锁的实现，redis天生就是单线程，不需要特殊处理

## Redis操作有哪些可能发生阻塞
-  集合全量查询查询
	- 尽量避免对超大集合使用全量查询，或者压根就不要使用超大集合，可以结合业务做一下折衷
- 大key删除
	- 因为大key删除不仅要释放内存，操作系统还要把释放的内存加到free链表中，如果释放内存很多，会发生阻塞，尽量不要使用大key，或者可以采取分段删除的方式，Redis 4.0提供了异步删除的方式，如果业务允许，则可以使用
- 同步AOF
	- RDB是纯异步操作，不会阻塞，但是AOF如果配置了同步写的话，会发生主线程和磁盘的频繁交互，阻塞主线程，推荐appendfsync不使用always，使用 everysec即可
- flushdb
	- 删除所有的key效果比大key删除更为严重，但是这个操作在正常服务的生产环境中极少使用，就不重点说了
- 主从同步
	- 主节点同步时都是异步执行的，不会阻塞主节点，但是从节点首次接受RDB的时候会使用flushdb并且是同步载入RDB，会发生阻塞，但是因为此时从节点没有请求，这种情况无伤大雅
 
## Redis有哪些淘汰策略
淘汰策略就是Redis满了的时候要删除一些key释放空间，有以下几种策略
- noevication
	- 不逐出， 内存满了也不删除任何数据，适用于不能丢失数据的场景，不适用不同的缓存场景
- all keys random
	- 从所有key中随机删除一些key
- all keys ttl
	- 从所有key中随机选取一些key，然后选取最近过期的数据进行删除
- all keys lru
	- 从所有key中随机选取一些key，然后根据操作时间选取最旧没被使用的key删除
- all keys lfu
	- 从所有key中随机选取一些key，然后根据操作次数选取使用最少的key删除
- volitale keys random
	-  从设置过期时间的key中随机删除一些key
- volitale keys ttl
	- 从设置过期时间的key中随机选取一些key，然后选取最近过期的数据进行删除
- volitale keys lru
	- 从设置过期时间的key中随机选取一些key，然后根据操作时间选取最旧没被使用的key删除
- volitale keys lfu
	- 从设置过期时间的key中随机选取一些key，然后根据操作次数选取使用最少的key删除
- 选择策略
	- 业务上可能过期都要设置过期时间
	- 淘汰策略使用volitale keys lru

## Redis的持久化
- RDB
  - 需要将全量数据写入磁盘，即使是异步，也会占用很多资源，影响性能
  - 频率不宜过高
  - 重启恢复数据很快
  - 这个过程使用的COW，只有在住进程发生数据变更的时候会把数据复制给子进程内存
- AOF
  - 采用的是追加写，性能损耗较小
  - 三种频率 always everysec no  always每次刷盘不推荐 不需要持久化使用no 需要持久化使用everysec
  - 重启恢复速度慢
  - 当AOF文件很大的时候Redis会fork子进程进行AOF重写，即那内存中最新的数据通过插入的命令保存到磁盘上，这个过程使用的COW，只有在住进程发生数据变更的时候会把数据复制给子进程内存
- 选择
  - RDB频率频率高性能损耗过大，频率低丢数据风险太大，一般不用
  - AOF everysec异步写入，性能损耗可以接受，数据最多丢失1s，一般采用这这种方式
