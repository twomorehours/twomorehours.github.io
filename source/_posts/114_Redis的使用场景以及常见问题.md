---
title: Redis的使用场景以及常见问题
date: 2020-07-07 23:30:39
categories:
- Redis
---

## String的使用场景
- 保存对象
  - 这是最常见的缓存使用场景，保存应用程序中的一个对象
- 分布式锁
  - 使用setnx实现分布式锁

## List的使用场景
- 实现队列
  - 通过RPUSH LPOP实现分布式队列

## Set的使用场景
- 保存一批相同类型相同意义的数据，去重
  - 如保存一个人的资产，一本书的章节等
  
## Hash的使用场景
- 保存一个对象，这个对象的的字段需要单独读写
- 保存一批相同类型的KV数据，对用应用程序中Map的使用场景

## Zset的使用场景
- 排行榜
  - 通过score进行排序
- 时间序列数据
  - score设置为时间，根据时间排序
- 延时队列
  - socre为当前时间+延时时间，从头取出

## Bitmap的使用场景
- 签到信息
  - 签到标记为1 未签到为0
- 布隆过滤器
  - 用于减少无效请求穿透到数据库

## HyperLogLog的使用场景
- UV计算
  - 是用概率统计算法实现相同User的去重，有一定误差，但是占用空间极小，对精确度没有太高可以考虑使用

## Redis的内存碎片
- Redis一般使用jemalloc分配内存，分配内存时都是固定大小的，所以一定有一些剩余
- 删除数据的时候，空间不会立即返还给操作系统也会造成内存碎片
- 这些内存碎片重用率较低
- 重启可以去除碎片，但是没有实操意义
- Redis4以上增加了碎片整理功能
- info memory查看信息
```text
# Memory
used_memory:36921568 # 存储的值占用的内存
used_memory_rss:26771456 # 实际分配的内存
mem_fragmentation_ratio:0.73 # 实际分配内存 / 存储的值占用的内存
# 如果mem_fragmentation_ratio > 1 则证明有未使用的内存，如果超过1.5则证明有三分之一的空间未使用，需要处理
# 如果mem_fragmentation_ratio < 1 则说明分配的分配的内存不足 使用了swap 需要立即增加内存
```

## 缓存一致性问题
- 先删除缓存再更新数据库
  - 并发情况下，如果查询请求先于更新请求查询了数据库，并且后于更新请求更新了redis，则会出现不一致
- 先更新数据库再删除缓存
  - 并发情况下， 如果恰好缓存不存在（首次或者过期），会出现上面同样的问题
- 先更新数据库再更新缓存
  - 并发情况下，先更新数据库的请求晚于后更新数据库的请求更新缓存，则会出现不一致
- 选择
  - 一般选择使用先更新数据库再删除缓存，因为其出现问题概率较小，配合短的过期时间，能尽量减少缓存不一致的时间
  - 如果不能容忍缓存不一致，如更新用户账户余额等，则需要加分布式锁

## Redis的常见问题
- 缓存雪崩
  - 大量key同时过期，大量请求直接打到数据库
    - 过期时间加上随机值
  - Redis宕机
    - 搭建高可用集群
- 缓存击穿
  - 某个热点数据过期，大量请求同时打到数据库
    - 热点数据不过期不淘汰
- 缓存穿透
  - 查询不存在的key，直接传过缓存打到数据库，可能是恶意请求
    - 缓存空值，适用于key比较集中的且量小的情况
    - 使用布隆过滤器
    - 前端判别恶意请求